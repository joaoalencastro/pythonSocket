Próximos passos:
	[IMPORTANTES]
		- Expandir o tanto de pacotes que eu consigo capturar
		- Colocar o DNSStager pra rodar
			E então, diferenciar tráfego criptografado (DNSStager) do não criptografado
		- Em sequência, devo plotar de algum CSV essas entropias.

	- O DNSStager usa XOR, depois devo usar uma criptografia de verdade, como, AES256.
	- Tirar os índices que já foram trabalhados
	- Criar uma classe para o pacote
		Criar diferenciação de flags do tcp (por ora usarei UDP)
			Protocolos famosos que usam UDP são: {DNS:53,DHCP:67,68,TFTP:69,SNMP:161,162,NFS:2049}
	- Usar a query "track_total_hits" p/ falar exatamente o numero de hits 'eq'


TMP INFO:
packets-2021.08.19
"tcp_tcp_flags_ack" : true

Blz, nao dá pra puxar todos os pacotes de um índice de uma vez. Tenho que pegar os ids ants.

Meu programa está calculando a entropia para 

Reunião
	Uma outra entropia pode se Entende-se que é um custo computacional baixo
	XOR NAO EH CRIPTOGRAFADO, ALGORITMO DE CRIPTOGRAFIA EH CRIPTOGRAFIA
	DEVO CRIAR UMA TABELA PARA COMPARAÇÃO DE ENTROPIAS [NORMAL, HASH, XOR, AES256]
	
	[EXTREMAMENTE IMPORTANTE]
	Esse fds focar em achar artigo que resolve esse problema
			A entropia resolve esse problema pra mim? Ela descobre se há criptografia ou não?
	
	
PRÓXIMA REUNIÃO

	- Mandar um simples parágrafo em plain text, e ciphered e criptografado.
	
	
	
	
	
	
	
layers.tcp.tcp_flags_tcp_flags_str_raw.keyword : "8018" or layers.tcp.tcp_flags_tcp_flags_str_raw.keyword :"5018" or
layers.tcp.tcp_flags_tcp_flags_str_raw.keyword :"5010"


-		·······AP···				PSH, ACK		0x018	Application Data
5010 -	.......A...					ACK				0x010	Not App Data
5011	.......A..F					FIN, ACK		0x011	Not App Data
8002	.........S.					SYN				0x002	Not App Data
5018	........P..					PSH				0x018	Application Data
									RST				0x004	Not App Data

									PSH, ACK		0x018
									

-> Separar os TCPs por flags #Na vdd não pq isso excluiría pacotes TCP válidos que não têm essa propriedade 
	$ Na vdd, se eu separar pelo tamanho do pacote não haverá problema.
-> Devo plotar em ordem crescente do tamanho de pacote (não sei se o plot ordena ou se devo fazer isso antes)
	$ O plot por tamanho crescente não é tão interessante por agora.
-> Criar fluxos de 256 bytes

	~~~~~~~~ATENÇÃO~~~~~~~~
-> A função da BiEn briga comigo dizendo que não deve ser usada em string binarárias maiores que 32 bits.
-> Olhar no artigo como Shannon foi calculado pra ficar entre 0 e 1

Primeiro farei os fluxos com 32 bits
continuando, irei mudar o tipo de plot box pq nao dá pra ver direito onde estao os valores
preciso adicionarmais granularidade, mais casas decimais, uma grid, e normalizar a entropia de shannon.

~~~~~~~~~Depois de reler o artigo da BiEntropia~~~~~~~~~~
Sei que os testes foram realizados por uma janela deslizante de 32 bits, e depois calculada a média e o desvio padrão dessas janelas.
Já para a TBiEn foram feitos testes com janelas deslizantes maiores que 32 bits, como, por exemplo, 256 bits. E ainda sim, sempre por janelas deslizantes.
Porém, para o teste de criptografia, eles usaram especificamente o algoritmo TBiEn com uma janela deslizente de 1024 bits por 1000 seções.

Para a próxima prática: 
	-> Selecionar um tamanho fixo de janela deslizante para a BiEn e outro para a TBiEn e realizar os testes novamente de acordo com a tabela que o Robson mostrou de tcp criptografado e não criptografado e udp criptografado e não criptografado. Ps:. Lembrando que ataques de C&C utilizam pouco espaço em pacotes, já que podem utilizar sinais. 
		Tamanhos:
			shannon_window: Não será por janela deslizante ~tamanho mínimo: 8bits (o pacote não pode ter mais que dois símbolos hex)
			bien_window: 32 bits ~tamanho mínimo: 2bits ~tamanho máximo: 32bits
			tbien_window: 32 bits ~tamanho mínimo: 2bits (explicar que não faz sentido utilizar apenas 2 bits; ou entropia 0 ou entropia 1) ~tamanho máximo: não há máximo (a fins de estudos.....explicar de o porquê usar 32 bits)
		Tipos/Cenários (capturas limpas):
			- Cenário 1: UDP_plaintext
			- Cenário 2: UDP_encrypted
			- Cenário 3: UDP_DNS_legitimo
			- Cenário 4: TCP_plaintext
			- Cenário 5: TCP_encrypted
			- Cenário 6: TCP_HTTP_legitimo
			- Possível cenário 7: dns cover channel: ex.: dns stager

	Teoria:
		Falar que não precisa haver tanta preocupação com TLS, pois hoje em dia, equipamentos de borda já são extremamente restritos com a checagem por certificados e CAs. Além daqueles que são capazes de realizar inspeção do tráfego SSL/TLS ao fazerem a interceptação dos pacotes criptografados.
		Explicar também que alguns bytes devem ser descartados devido ao limite imposto pelo cálculo da entropia. Dê exemplo.
		
	Dúvidas:
		
	Devo:
		mudar a estratégia de envio
		fazer o corte menos pra shannon (análise) qual o tamanho mínimo
		Deixar claro que eu não estou fazendo a comparação entre as diferentes entropia. As amostras são comparadas entre mesmas entropias.
		Um novo gráfico comparar plaintext e cypher text p/ cada algoritmo de entropia
		Ler de novo o paper novamente e ter uma explicação para o máximo do tbien.


MiKTeX: C:\Users\João\AppData\Local\Programs\MiKTeX

A INDEXAR:
128bytesAESrfc761.pcapng
32bytesAESrfc761.pcapng 					packets-2021.09.21
64bytesAESrfc761.pcapng 
UDP_32bytes_encryptedAES_rfc761.pcapng		packets-2021.09.22

A CAPTURAR:
UDP_64bytes_encryptedAES_rfc761.pcapng
UDP_128bytes_encryptedAES_rfc761.pcapng
UDP_32bytes_plaintext_rfc761.pcapng
UDP_64bytes_plaintext_rfc761.pcapng
UDP_128bytes_plaintext_rfc761.pcapng




















